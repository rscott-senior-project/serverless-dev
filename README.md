AWS Developer Associate Content Series : Developing a Serverless Application
============================================================================

Created by Rob Scott, last modified on May 09, 2022

This demonstration will set up AWS Lambda, a function-as-a-service compute, and attach a DynamoDB table. The requests will be routed through API Gateway, the API management service for AWS.

**Note**

This demonstration will use The Serverless Framework to deploy code and resources to AWS. It uses the same processes as the AWS provided tools to deploy code.

Getting Started
---------------

We will use the Serverless Framework again to provision and deploy resources to AWS. It will start with the most basic server template, and the demonstration will add a DynamoDB table and some functions that interact with the database.

All of the resources are provisioned as _infrastructure-as-code_ in the demonstration. Have the AWS console open to verify that Serverless has deployed them properly. Start the Serverless framework by typing `serverless` in the terminal.

Select Nodejs Express API and answer the rest of the prompts. Ignore questions about using the Serverless dashboard-- the AWS Console has all of the same features necessary for deploying the application.

### Initial Infrastructure as Code

All resources are defined and managed through the `serverless.yml` file. It should look something like this right now:

    service: <app-name>
    frameworkVersion: '3'
    provider:
      name: aws
      runtime: nodejs12.x

    functions:
      api:
       handler: handler.handler
       events:
         - httpApi: '*'

Right now, the only resource defined is our Lambda function. That handler for the Lambda should be a method defined in `handler.js`, another file auto generated by Serverless. When the function is provisioned, AWS knows to create an API Gateway API to invoke the Lambda.

### Express API

Express is a popular JavaScript library for writing web server code. This application of Express is a REST API. More about REST design can be found [here](https://www.bing.com/ck/a?!&&p=234e69c9c1763f3b251ed2fc6109708734d87a8873d816e037990585ecd37523JmltdHM9MTY1MTUxMTM0OSZpZ3VpZD03YmJmOGUxNC01ZmUzLTQwOWQtODg1My05ZjcyZDg4NGY3MWEmaW5zaWQ9NTE3OA&ptn=3&fclid=9499514f-ca3a-11ec-b580-2bd833fc16ea&u=a1aHR0cHM6Ly93d3cuaWJtLmNvbS9jbG91ZC9sZWFybi9yZXN0LWFwaXM&ntb=1). Let's break down what the handler code is doing:

    const serverless = require("serverless-http");
    const express = require("express");
    const app = express();

    app.use(express.json());

    app.get("/", (req, res, next) => {
      return res.status(200).json({
        message: "Hello from root!",
      });
    });

    app.get("/hello", (req, res, next) => {
      return res.status(200).json({
        message: "Hello from path!",
      })

Express makes it really convenient to define API routes and their specific HTTP execution (GET, POST, etc). These can be changed to carry out the logic that includes a DynamoDB table.

### Deploy

Use `serverless deploy` to deploy the resources and code to AWS. Use the AWS Console to confirm that the resources are there. In addition, Serverless should include a URL for invoking that Lambda function. Paste that in a web browser or `curl` the endpoint to make sure it works appropriately.

Using the Provided Script
-------------------------

In order to use the script, there will need to be another `secrets` directory that will be kept only on the local repository. Use the following commands to set this up:

mkdir secrets
vim secrets/endpoint

In the editor, the text should look like this:

    {
      "url": <URL>
    }

**NOTE:** Add the `secrets/` directory to your `.gitignore` to avoid publishing the URL to GitHub

The `dynamo-api.sh` script will grab the API endpoint from your secrets file and use it when calling `curl`.

### Script Instructions

`./dynamo-api.sh [ op ] [ key ] [[ name ]]`

**Where:**

*   **op** = -p | -g | -t (AddItem, Items, Root)
    
*   **key** = itemKey (always required)
    
*   **name** = name (required when op is -p)
    

**NOTE:** Only the `-t` option will work until the database logic is added. The `-p` and `-g` routes do not exist yet.

Adding a DynamoDB Table
-----------------------

Serverless can deploy a DynamoDB after it is properly defined in the `serverless.yml`. It should look like this now:

    service: serverless-dev-demo
    frameworkVersion: '3'

    custom:
      tableName: '<NAME>-${sls:stage}'

    provider:
      name: aws
     runtime: nodejs14.x
      iam:
       role:
          statements:
            - Effect: Allow
              Action:
                - dynamodb:Query
                - dynamodb:Scan
                - dynamodb:GetItem
                - dynamodb:PutItem
                - dynamodb:UpdateItem
                - dynamodb:DeleteItem
              Resource:
                - Fn::GetAtt: [ DemoTable, Arn ]
      environment:
        DEMO\_TABLE: ${self:custom.tableName}

    functions:
      api:
        handler: handler.handler
        events:
          - httpApi: '*'

    resources:
      Resources:
        DemoTable:
          Type: AWS::DynamoDB::Table
          Properties:
            AttributeDefinitions:
              - AttributeName: itemKey
                AttributeType: S
            KeySchema:
              - AttributeName: itemKey
                KeyType: HASH
            BillingMode: PAY_PER_REQUEST
            TableName: ${self:custom.tableName}

There are a handful of additions that are necessary to add this table-- lets break down the key features:

### Line 4 - Custom

Custom flag lets the programmer define variables that will be used in references later on. In this scenario, this is the name the AWS will provision our table under. Obviously, that reference is likely to be used in other contexts. As a result, it would be convenient to define a custom parameter called `tableName` to be used instead of the longer AWS name.

### Line 10 - IAM

For AWS resources to interact with each other, they need to be equipped with IAM policies, much like any ordinary AWS user. Now, the Lambda function has been given permissions to perform the standard read/write operations on DynamoDB.

The _specific_ table is defined under Resource, and it uses an **intrinsic function** to grab a variable not actually present in the code. This is a feature of AWS CloudFormation, the main Infrastructure-as-Code manager. CloudFormation Templates use intrinsic functions when programmers want to dynamically reference resources. In this case, the function is specifying the Amazon Resource Name (ARN) of the table in our environment. To apply these DynamoDB permissions, the template must specify that the actions are permitted on a particular table, specified by the ARN.

**Exam Tip:** There will be another section on CloudFormation and some of its features, but it is good to know for now that **intrinsic functions** dynamically get properties of specified in infrastructure templates.

### Line 33 - Resources

This is the main section that defines the table and how it should be configured. First, `DemoTable` is defined as the Resource name. This could be any arbitrary name, it mainly is a syntactical reference to the resource being defined.

The properties specify the key scheme and the names of each column expected in the table. The most important component is the primary key of the table. This key is also known as the _partition key._ Use this properties section to define the name of the partition key as well as its type.

### Line 43 - Billing Mode

Billing mode was a new field to me when working with this template. Free-tier AWS offers a significant amount of DynamoDB requests before the requests start requiring payment.

### Line 44 - Table Name

Once again, the custom field helps the programmer reuse variables instead of hardcoding the table name.

Adding Database Logic in Lambda
-------------------------------

Next, the Lambda function needs additional logic and dependencies to operate on DynamoDB. This will cover the AWS SDK and how to make it interact with the table.

### AWS Software Development Kit

The SDK is a JavaScript library that is meant to interface with AWS resources in code.

**Exam Tip:** Think of the AWS SDK when:

*   AWS compute resources want to interact with other resources
    
*   Refactoring from HTTP request-based communication
    

To install the SDK, use: `npm install aws-sdk` in the project’s root directory

Next, add this line of code to the top of `handler.js`:

    const AWS = require("aws-sdk");

Add these two lines after the existing dependencies:

    const DEMO\_TABLE = process.env.DEMO_TABLE;
    const dynamodb = new AWS.DynamoDB.DocumentClient();

Now we have all of the dependencies to work with DynamoDB in the Lambda function!

### Add a Write API Path

The Express Server (operating under this single Lambda) will need a POST request to add items to the database. Add the following code in `handler.js`

    app.post("/addItem", async function (req, res) {
      const { itemKey, name } = req.body;

      const params = {
        TableName: DEMO_TABLE,
        Item: {
          itemKey: itemKey,
          name: name
        },
      };

      try {
        await dynamodb.put(params).promise();
        res.json({ "itemKey": itemKey, "name": name });
      } catch (error) {
        console.log(error);
        res.status(500).json({ error: error });
      }
    });

### Add a Read API Path

The server also needs some simple code to perform reads on the database. Add the following code to the `handler.js`

    app.get("/items", async function (req, res) {
  
      const params = {
        TableName: DEMO_TABLE,
        Key: {
          itemKey: req.body.itemKey,
        },
      };

      try {
        const { Item } = await dynamodb.get(params).promise();
        if (Item) {
          const { itemKey, name } = Item;
          res.json({ itemKey, name });
        } else {
          res
            .status(404)
            .json({ error: '404: Could not locate item' });
        }
      } catch (error) {
        console.log(error);
        res.status(500).json({ error: "Could not locate item" });
      }
    });

This function will use the SDK to query for one particular item. That item’s partition key is specified in the argument.

### Verify Paths

Use `serverless deploy` to deploy the changes to AWS. This will provision the table with the specified characteristics and add these two server routes to the Express Server Lambda. For example, these two routes can be tested by using the `dynamo-api.sh` script:

    ./dynamo-api.sh -p key123 name123
    // expect response repeating the object that was just added

    // to verify that the item was added to the table, retrieve it..
     ./dynamo-api.sh -g key123

In the script, the first operation flag is determining which route to hit. After the deployment, Serverless outputs the link to invoke the Lambda. Each path in the `handler.js` needs to be appended to the end of the URL in order to invoke that particular endpoint (i.e. `/users` , `/hello`)

Document generated by Confluence on May 10, 2022 20:11

[Atlassian](http://www.atlassian.com/)
